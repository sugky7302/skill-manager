# 程式碼撰寫規則
為了統一自己的程式碼風格，在後續維護或開發其他項目上能夠清晰明瞭，特意蒐集網路上或書籍中對程式碼格式的見解，消化吸收後規範成文，讓日後能有個憑依。要記得，程式碼風格無所謂好壞，只要所有程式碼一致，就是好風格。

## 目錄
- 原則
	- [基礎](#基礎)
	- [系統架構](#系統架構)
	- [設計方法](#設計方法)
	- [類別](#類別)
	- [子程序](#子程序)
	- [偽代碼](#偽代碼)
	- [變量](#變量)
	- [基礎數據類型](#基礎數據類型)
	- [結構體](#結構體)
	- [全域數據](#全域數據)
	- [寫法](#寫法)
	- [表驅動法](#表驅動法)
	- [布林表達式](#布林表達式)
	- [結構化編程](#結構化編程)
	- [軟體質量](#軟體質量)
	- [註釋](#註釋)
	- [測試](#測試)
- [通用](#通用)
- [變數](#變數)
- [常數](#常數)
- [函數](#函數)
- [類型](#類型)
- [文件](#文件)

## 參考
- 無瑕的程式碼：敏捷軟體開發技巧守則,  Robert C. Martin
- 編譯可讀代碼的藝術, Dustin Boswell & Trevor Foucher, 尹哲 & 鄭秀雯 譯
- 代碼大全, Steve McConnell, 電子工業出版社 譯
- 重構--改善既有程式碼的設計, Martin Fowler, 熊節 譯
- 深入淺出設計模式, Eric Freeman & Elisabeth Freeman with Kathy Sierra & Bert Bates, O'Reilly Taiwan 譯

## 原則
### 基礎
- 程式碼結構的好壞要用「代碼行數」、「時間複雜度」、「內存消耗」與「準確率」做比較
- 程式碼要能讓人快速理解、輕鬆維護、容易擴展
- 程式碼的寫法應當使別人理解它所需的時間最小化
- 一次只做一件事
    - 列出程式碼所做的所有任務
    - 盡量把這件任務拆分到不同的函數中
- 用自然語言描述程式碼要做什麼，把想法變成程式碼
- 把條件、循環以及其他隊控制流的改變做得越"自然"越好，運用一種方式使讀者不用停下來重讀你的代碼
- 通過提早返回(Guard Clause原則)來減少嵌套
- 把你的超長表達式拆分成更容易理解的小塊
- 總結變量:用一個短很多的名字取代一大塊代碼，例如取代條件語句
- 減少變量
- 減少中間結果
- 減少控制流變量
- 縮小變量的作用域
- 如果類別的成員變量只有少量方法用到，那就把它降格進方法內
- 把大東西拆分成小東西，彼此獨立才有作用，主要動機是數據分離
- 如果某個變量必須被某一個函數所使用，且無法改成local，可以考慮把函數變成閉包來處理
- 只寫一次的變量更好:只設置一次值的變量(或常量)使得代碼更容易理解
- 抽取不相關的子問題
- 簡化已有接口，永遠不要安於使用不理想的接口
- 找出應用中可能需要變化之處，把它們獨立出來，不要和那些不需要變化的程式碼混在一起
- 策略模式: 定義了算法族，分別封裝起來，讓它們之間可以互相替換，此模式讓算法的變化獨立於使用算法的客戶
	- 針對接口編程(超類型編程)，而不是針對實現編程。關鍵在多態，針對接口編程準確來說是「變量的聲明類型應該是超類型，通常是一個抽象類或是一個接口，如此，只要是具體實現此超類型的類所產生的對象，都可以指定給這個變量。
	- 多用組合，少用繼承。組合就像車子一樣，各部位的組件都是獨立的，有些車子要用，有些車子不要用，都可以輕易組裝拆卸，而不會出現任何問題。
	- 繼承和組合的使用時機差別在於，該程式碼是幾乎都不一樣且無法大量復用或全部都一樣(組合)，還是有固定模式且可復用。
- 觀察者模式: 出版者(ex: 報社) + 訂閱者(ex: 訂戶)。定義了對象之間的一對多依賴，這樣一來，當一個對象改變狀態時，它的所有依賴者都會收到通知並自動更新。
	- 為了交互對象之間的松耦合設計而努力
- 裝飾者模式: 動態地將責任附加到對象上。若要擴展功能，裝飾者提供了比繼承更有彈性的替代方案。
	- 裝飾者和被裝飾對象有相同的超類型
	- 類應該對擴展開放，對修改關閉
	- 裝飾者可以在所委託被裝飾者的行為之前與/或之後，加上自己的行為，以達到特定的目的。這是一種疊加的行為。
- 工廠方法模式: 定義了一個創建對象的接口，但由子類決定要實例化的類是哪一個工廠方法讓類把實例化推遲到子類。
	- 要依賴抽象，不要依賴具體類
	- 變量不可以持有具體類的引用
	- 不要讓類派生自具體類
	- 不要覆蓋基類中以實現的方法
	- 抽象工廠模式提供一個接口，用於創建相關或依賴對象的家族，而不需要明確指定具體類。
- 單件模式: 確保一個類只有一個實例，並提供一個全局訪問點。
	- 使用私有建構器
- 命令模式: 將"請求"封裝成對象，以便使用不同的請求、隊列或者日誌來參數化其他對象。命令模式也支持可撤銷的操作。
- 適配器模式: 將一個類的接口，轉換成客戶期望的另一個接口。適配器讓原本接口不兼容的類可以合作無間。
	- 適配器類要實現客戶的類別，而不是被適配者的類別
	- 對象適配器是把請求委託給被適配者處理
	- 類適配器是多重繼承需求和被適配者
	- 意圖是將接口轉換成不同接口。
- 外觀模式: 提供了一個統一的接口，用來訪問子系統中的一群接口。外觀定義了一個高層接口，讓子系統更容易使用。
	- 意圖是簡化接口
	- 最少知識原則: 只和你的密友談話。不要讓太多的類偶合在一起，免得修改系統中一部份，會影響到其他部分。
	- 對任意對象，在該對象的方法中，我們只調用:
		- 該對象
		- 被傳參的對象
		- 此方法所創建或實例化的對象
		- 對象的任何組件
		- 如果某對象是調用其他方法的返回結果，不能再調用此對象內的方法。
- 模板方法模式: 在一個方法中定義了一個算法的骨架，而接一些步驟延遲到子類中。模板方法使得子類可以在不改變算法結構的情況下，重新定義算法中的某些步驟。
	- 高層組件對待低層組件的方式是「別調用我們，我們會調用你」
- 迭代器模式: 提供一種方法順序訪問一個聚合對象中的各個元素，而又不暴露其內部的表示。
	- 一個類應該只有一個引起變化的原因
- 組合模式: 允許你將對象組合成樹形結構來表現"整體/部分"層次結構。組合能讓客戶以一致的方式處理個別對象以及對象組合。

### 系統架構
- 系統
- 子系統和套件
- 套件中的類別
- 類別中的數據和子程序
- 子程序內部

### 設計方法
- 理解問題
	- 未知量
	- 條件
	- 數據
	- 使用畫圖能夠輕鬆釐清彼此之間的關係
- 設計一個計劃
	- 找出彼此之間的關係
	- 搜尋類似的已解決的問題
	- 如果解決不了問題，先找出特化版的問題予以解決
	- 用上全部的數據、條件
	- 考慮問題涉及的所有的核心概念
	- 建立一個實驗性原型(用於回答特定設計問題、量最少且能夠隨時扔掉的程式碼)
- 執行計劃
	- 執行的過程中要檢查每一步是否正確
- 回顧
	- 測試結果是否正確

### 類別
- 將實現細節隱藏在其中，讓使用者不用思考該怎麼實現
- 公開函數必須要讓使用者一看就理解該怎麼使用，且須與類別職能一致
- 一定要抓緊類別的職能方向，必須單一
- 好的類別其抽象與內聚的程度也高
- 盡可能限制類和成員的可訪問性，根據需求考慮暴露成員數據，例如:point有x這個座標參數，如果setX、getX只是單純存取x而內部沒有額外操作的話，應該直接使用point.x
- 不要對類別的使用者做出任何假設
- 撰寫優良的接口和子程序，閱讀程式碼時能夠一目瞭然
- 切記！千萬不要因為一個子程序裡僅使用公用子程序，就把它歸入公開接口
- 類別和其成員是「包含(has a)」的關係，而父類別和子類別是「繼承(is a)」的關係
- 一個類別不要超過9個成員參數
- 子類別是父類別的一個特殊版本，如果子類別不完全遵守父類別定義的同一接口契約，請使用包含的方式，或是對父類做修改
- 如果類別只有一個實例，考慮要不要直接改成對象
- 不要創建任何並非絕對必要的繼承結構
- 如果許多子類別覆蓋了某個父類別接口，但修改了此接口的語意，這通常表示父類別的設計有問題
- 盡量減少類和類之間相互合作的範圍
- 創建類別的原因
	- 為現實對象建模
	- 為抽象的對象建模
	- 降低複雜度
	- 隱藏實現細節
	- 限制修改的影響範圍
	- 讓程式碼更易於重用
- 避免創建萬能類
- 類別必須具有數據成員和行為成員兩個方面，缺一都要考慮如何修改

### 子程序
- 必須有單一目的
- 降低複雜度
- 提高可讀性，讓使用者清楚該程式碼的用意，甚至取代註釋
- 避免重複
- 簡化條件判斷
- 提高可移植性
- 改善性能
- 使用語氣強烈地動詞加賓語命名能夠清楚表達用途
- 使用所有的參數
- 不要把參數用作中間變量

### 偽代碼
- 創建類別的步驟為以下程序，->N 表示下個可執行的步驟編號
	1. 開始->2
	2. 創建類別的總體設計: 定義職責、精確定義接口所表示的概念、決定是否繼承或是可繼承、標示要用到的數據成員->3
	3. 創建類別中的子程序->2 4
		1. 開始->2
		2. 設計子程序->3
		3. 檢查設計->2 4
		4. 編寫子程序的程式碼->5
		5. 檢查並測試->2 4 6
		6. 完成
	4. 檢查並測試整個類別: 子程序要測試，整個類別可以使用後再對整體進行檢查和測試->2 3 5
	5. 完成
- 使用類似英語的語句來精確描述特定操作
- 避免使用目標編程語言中的語法元素，要站在比程式碼高的層次去撰寫，這樣就能套用在不同語言上
- 用偽代碼去描述解決問題的方法的意圖
- 要不斷精化偽代碼，加入越來越多的細節，直到看起來已經很容易直接寫出程式碼為止
- 寫出程式碼後，將偽代碼當作註釋，因此你要做的是刪除多餘的註釋，而不是加進來
- ex: 通過偽代碼創建子程序
	- 檢查先決條件
	- 定義子程序要解決的問題
		- 要隱藏的訊息
		- 輸入參數
		- 輸出值
	- 命名
	- 決定如何測試子程序
	- 找尋有無已經寫好且可用的好的程式碼，如果找不到可以去找算法或模型
	- 思索子程序的所有執行路徑，考慮其錯誤處理
	- 編寫偽代碼
		- 頂端註釋: 寫下該子程序的目的
	- 如果子程序的重點是對數據類型的操作，那要先設計好數據類型
	- 檢查偽代碼
	- 在偽代碼中試驗一些想法，留下最好的想法(迭代)
	- 轉成程式碼: 無特定順序，但所有步驟都會實現
		- 寫出子程序的聲明
		- 編寫第一條和最後一條語句，然後將偽代碼轉換為高層次的註釋
		- 每條註釋下面填寫程式碼
		- 檢查程式碼是否需要進一步分解
		- 逐步執行程式碼來檢查錯誤
		- 測試
		- 收尾
			- 檢查接口
			- 檢查設計質量，確定子程序只做一件事
			- 檢查是否有命名不好的變量或是沒用到的變量
			- 檢查語句和邏輯
			- 檢查佈局
			- 檢查文字說明、註釋是否精確
			- 刪除冗餘的註釋

### 變量
- 盡量靠近第一次使用變量的位置聲明並初始化該變量
- 注意計數器和累加器
- 在類別的建構函數裡初始化該類別的數據成員
- 低跨度和低存活時間
	- 計算變量跨度(兩次引用之間間隔的程式碼數)
	- 計算存活間(第一次引用和最後一次引用間隔的程式碼數)
- 把相關語句放到一起
- 把相關語句組提取成單獨的子程序
- 每個變量只用於單一用途
- 避免隱含含意和雙重用途，ex: page_count的取值可能表示已列印紙張的數量，除非它等於-1，在這種情況表明有錯誤發生。這個例子就是整數和布林混用
- 確保使用了所有已聲明的變量
- 命名要完全、準確地描述出該變量所代表的事物
- 變量名的最佳長度在10-16個字符，8-20亦可，最主要是要能夠表達清晰
- 長名字的變量適用於很少用到的變量或全域變量，短名字的變量適用於局部變量或循環變量
- 變量的名字若有限定詞，例如：total、sum、max等等，所有變量都要保持一致性
- 常用的對稱命名
	- begin/end
	- first/last
	- locked/unocked
	- min/max
	- next/previous
	- old/new
	- opened/closed
	- visible/invisible
	- source/target
	- source/destination
	- up/down
- 約定俗成的變量名可以適時使用，但重點是不要造成誤解
- 旗幟變量不要命名xxxflag，這違反了原則
- 中間(暫存)變量的命名也要表達清晰
- 布林變量不要給予同時隱含真假的名字，例如：status，要使用肯定的命名，以下為幾個有用的名字
	- done: 表示事情已經完成
	- error: 表示有錯誤發生
	- found: 表示某個值已經找到了
	- success/ok: 表示某個操作是否成功
- 不要在前面加is，這也會同時隱含真假
- 有些變量名可以使用縮寫，但是必須採用標準的縮寫
- 避免在名字中使用數字

### 基礎數據類型
- 避免使用未經解釋的常量
- 使類型轉換變明顯
- 整數
	- 檢查整數除法
	- 檢查溢出
	- 檢查中間結果溢出
- 浮點數
	- 避免數量級相差距大的數之間的加減運算
	- 避免等量判斷，例如0.1+0.1+...+0.1(10次)不一定等於1.0，因為會有機器誤差
- 字符和字符串
	- 避免使用神秘字符和神祕字符串
	- 如果你知道只需要支持一種文字的語言，請考慮使用ISO8859字符集；如果你需要支持多種語言，請使用Unicode
- 布林變量
	- 用布林變量修飾程序，使其易讀
	- 用布林變量來簡化複雜的判斷
	- 如果需要的話，創建你自己的布林類型
- 枚舉類型
	- 用枚舉類型提高可讀性
	- 用枚舉類型提高可靠性
	- 用枚舉類型來簡化修改，例如：1代表紅色、2代表綠色這個方案發現一處缺陷，你就必須從頭到尾檢查程式碼，如果用枚舉類型，就只要向列表增加元素
	- 將枚舉類型作為布林變量的替換方案
	- 定義出枚舉的第一項和最後一項，以便用於循環邊界
	- 把枚舉類型的第一個元素留做非法值
- 具名常量
	- 在數據聲明中使用具名常量
	- 避免使用神秘常量，即便是安全的
- 數組
	- 確認所有的數組索引都沒有超出數組的邊界
	- 考慮用容器來取代數組，或者將數組作為順序化結構來處理
	- 如果數組是多維的，確認索引的使用順序是正確的
- 自定義數據類型
	- 給所創建的類型取功能導向的名字
	- 不要重定義一個預定義的類型
	- 考慮創建一個類而不是使用typedef

### 結構體
- 簡化對數據塊的操作
- 簡化參數列表
- 減少維護

### 全域數據
- 要求所有的程式碼通過訪問器子程序來存取數據，提高可讀性。例如：event_count = event_count + 1可以寫成AddEvent(event_count)

### 寫法
- 設法組織程式碼，使依賴關係變得非常明顯
- 使子程序名能凸顯依賴關係
- 利用子程序參數明確顯示依賴關係
- 用註釋對不清晰的依賴關係進行說明
- 使程式碼易於自上而下地閱讀。如果有人在閱讀你的程式碼的時候不得不搜索整個應用程序以便找到所需的訊息，那麼就應該重新組織你的程式碼了
- 把相關的語句放在一起。把相關的語句畫上框，如果方框彼此不交疊，表示這些語句排列得很好
- 先寫正常情況，再處理不常見的情況
- 把正常情況的處理放在if後面而不要放在else後面，這會讓程式碼容易閱讀、抓到重點
- 不要讓if內容是空的，else有內容
- 利用布林函數簡化複雜的條件
- 把最常見的情況放在前面
- 確保所有的情況都考慮到了
- 帶有跳出條件的循環要是單入單出的結構化控制結構
- 一個循環只做一件事
- 設法確認循環能夠終止
- 使循環終止條件看起來很明顯
- 不要為了終止循環而胡亂改動for循環的下標
- 在嵌套循環中使用有意義的變量名來提高其可讀性
- 循環下標變量的作用域只能在該循環內
- 循環要盡可能地短，以便能夠一目了然
- 把嵌套限制在3層以內
- 把長循環的內容移到子程序裡
- 由內而外地創建循環會比較輕鬆
- 確認遞迴能夠停止
- 把遞迴限制在一個子程序內

### 表驅動法
- 有些使用if-else或面向對象的邏輯方法去處理會很複雜的問題，使用要表驅動法，將格式規範好，利用程序轉換就會很簡單，詳見《代碼大全420-423》
- 除了直接訪問表、使用鍵值訪問表，還可以透過新建一套索引去對應鍵值，再從鍵值訪問表，這樣的優點是，鍵值跟表不需要更動，如果想要使用不同的搜尋方式，新建一套不同的索引即可
- 如果是無規則數據，使用階梯方法是不錯的方案。劃分區間，並將區間的上限寫入一張表。比對時只要一階一階搜尋即可，不需要遍歷表

### 布林表達式
- 隱式地比較布林值與true和false，例如：not done就比done == false要易讀
- 拆分複雜的判斷並引入新的布林變量
- 把複雜的表達式改成布林函數。不要因為這個判斷只用一次，就認為沒有必要把它放入一個子程序中，利用命名良好的函數，能夠提高可讀性
- 用決策表代替複雜的條件
- 在if子句中，把判斷條件從否定形式轉換為肯定形式，並互換if和else子句中的程式碼。如果if子句放的是正常情況，考慮把判斷條件改名字，例如原本式not statusOK改成statusFail
- 可以應用狄摩根定理將判斷式轉換成另一種形式，比如not A and not B->not(A or B)
- 利用括號使布林表達式更清晰
- 利用好短路判斷，條件要放對位置

### 結構化編程
- 任一控制流都可以用順序、選擇和迭代這三種結構生成
- 計算複雜度
	- 從1開始，一直往下通過程序
	- 遇到if、while、repeat、for、and、or，或者其同類的詞，就加1
	- 給case語句中的每一種情況都加1
	- 結果為1-5表示子程序可能還不錯
	- 結果為6-10表示得想辦法簡化子程序了
	- 結果為10+表示把子程序的某一部分拆分成另一個子程序並調用它
	- 一條情況很多的case語句很可能會包含超過10個元素，考慮case語句的用途再決定加多少

### 軟體質量
- 正確性：錯誤的稀少程度
- 可用性：使用上的容易程度
- 效率：占用資源多寡
- 可靠性：在指定的必須條件下，系統不會故障的時間長短
- 完整性：阻止未經驗證或不正確訪問的能力
- 適應性：在不做修正的情況下，能夠在應用或環境中使用的範圍
- 精確性：輸出結果的誤差程度
- 健壯性：系統在接收無效輸入或者壓力環境時繼續正常運行的能力
- 可維護性：是否容易對系統進行新增/刪除/修改
- 靈活性：當系統被用於其他目的或者環境的時候，需要對系統做修改的程度
- 可移植性：在原來設計的特定環境之外運行，對系統所進行修改的難易程度
- 可重用性：系統某些部分可被應用到其他系統中的程度以及此項工作的難易度
- 可讀性：閱讀並理解系統程式碼的難易程度，特別是在細節語句的層次上
- 可測試性：你可以進行何種程度的單元測試或系統測試
- 可理解性：在系統組織和細節語句層次上理解整個系統的難易程度

### 註釋
- 註釋的目的是盡量幫助讀者了解得和作者一樣多
- 加入「導演評論」，記錄你對代碼有價值的見解
- 為代碼中的瑕疵寫註釋
    - NOTE: 註釋
	- TODO: 我還沒處理的事情
	- FIXME: 已知的無法運行的代碼
	- HACK: 對一個問題不得不草用的比較粗糙的解決方案
	- BUG: 危險!這裡有重要的問題
- 給常量加註釋，讓讀代碼的人有了調整這個值的指南
- 站在讀者的角度，去想像他們需要知道什麼而給予註釋
	- 意料之中的提問
	- 公布可能的陷阱
	- 全局觀註釋，例如類別之間如何交互，數據如何在整個系統中流動等等
	- 總結性註釋
- 做任何能幫助讀者更容易理解代碼的事
	- 不管你心裡想什麼，先把它寫下來
	- 讀一下這段註釋，看看有沒有什麼地方可以改進
	- 不斷改進
- 寫出言簡意賅的註釋
    - 保持緊湊
    - 避免使用不明確的代詞
    - 潤色粗糙的句子
    - 精確描述函數的行為
    - 用輸入/輸出例子來說明特別的情況
    - 聲明程式碼的意圖
    - 採用訊息含量高的詞

### 測試
- 測試應當具有可讀性，以便其他程序員可以舒服地改變或者增加測試
- 你應當選擇一組最簡單的輸入，它能完整地使用被測代碼

## 通用
函數、變數、文件盡量給有描述性的命名，少用縮寫。若是要設為私有，則在名稱最前面加入下劃線，但局部變量不用加下劃線。

## 變數
變數名一律小寫, 單詞之間用底線連接，參數、類別靜態或非靜態變數亦同。類別成員變數必須以一條下劃線結尾。
變數聲明請放在使用函數的上面，過去放在最上面是因為舊的IDE限制。

## 常數
常數名採全大寫，單詞之間用底線連接，如：VARIABLE_TEST。

## 函數
函數名採*大駝峰法*，比如：MyFunction，取值與設值函數則要求與參數名匹配：SetNumEntries(num_entries)，不過類別內的方法採*小駝峰法*。
此外，函數內若有調用函數，請將函數寫在原函數下面，並於頂端聲明。若是遇到多個函數調用同一函數，則該函數需寫在最後調用它的函數後面。
其它非常短小的內聯函式(<10行)名也可以用小寫字母, 例如. 如果你在循環中呼叫這樣的函式甚至都不用緩存其返回值, 小寫命名就可以接受.

## 類型
類型、類別均使用大駝峰法，和[函數](#4)相同。若有慣用命名，則使用它。如果成員變量是函數，就按照函數的命名方式，也不用下劃線結尾。

## 文件
文件名要全部小寫，單詞之間用下劃線連接，比如：new_document。