/**
     * 删除 叶子节点 后的修复过程
     * @param deletedNode 被删除的节点
     * @param deletedNodeParent 被删除节点的父节点
     */
    private void deleteLeafFix(Node deletedNode){
        while((deletedNode != root) && (BLACK == deletedNode.color)){
            Node parent = deletedNode.parentNode;
            Node brother = getBrother(deletedNode);
            if(deletedNode.key.compareTo(parent.key) > 0){ // 删除的是右叶子节点
                if(RED == brother.color){ // case5: 如果该兄弟节点是红色的，那么根据红黑树的特性可以得出它的一定有两个黑色的子节点
                    brother.color = BLACK;
                    brother.rightNode.color = RED;
                    rightRotation(parent);
                    break;
                }else{
                    if((null == brother.leftNode) && (null == brother.rightNode)){ // case4: 兄弟节点是黑色的，且没有子节点
                        brother.color = RED; // 将兄弟节点设为红色，将父节点设为当前节点递归， 直到根节点，或遇到红色节点，
                        deletedNode = parent;
                    }else{
                        if((null != brother.leftNode) && (RED == brother.leftNode.color)){// case1: 兄弟节点是黑色的，且有一个左节点（可以断定 左节点是红色的）
                            //case3: 兄弟节点是黑色的，且有两个节点（可以断定 左右节点都是红色的） 这个和情况 1 是一样的
                            brother.color = parent.color;
                            parent.color = BLACK;
                            brother.leftNode.color = BLACK;
                            rightRotation(parent);
                            break;
                        }else{// case2: 兄弟节点是黑色的，且有一个右节点（可以断定 右节点是红色的）
                            brother.rightNode.color = BLACK;
                            brother.color = RED;
                            leftRotation(brother);
                        }
                    }
                }
            }else{// 删除的是左叶子节点
                if(RED == brother.color){ // case5 : 如果该兄弟节点是红色的，那么根据红黑树的特性可以得出它的一定有两个黑色的子节点
                    brother.color = BLACK;
                    brother.leftNode.color = RED;
                    leftRotation(parent);
                    break;
                }else{
                    if((null == brother.leftNode) && (null == brother.rightNode)){ // case4: 兄弟节点是黑色的，且没有子节点
                        brother.color = RED; // 将兄弟节点设为红色，将父节点设为当前节点递归， 直到根节点，或遇到红色节点，
                        deletedNode = parent;
                    }else{
                        if((null != brother.rightNode) && (RED == brother.rightNode.color)){ // case1 : 兄弟节点是黑色的，且有一个右节点（可以断定 右节点是红色的）
                            // case3 : 兄弟节点是黑色的，且有两个节点（可以断定 左右节点都是红色的） 这个和情况 1 是一样的
                            brother.color = parent.color;
                            parent.color = BLACK;
                            brother.rightNode.color = BLACK;
                            leftRotation(parent);
                            break;
                        }else{ // case2: 兄弟节点是黑色的，且有一个左节点（可以断定 左节点是红色的）
                            brother.leftNode.color = BLACK;
                            brother.color = RED;
                            rightRotation(brother);
                        }
                    }
                }
            }
        }
        
        deletedNode.color = BLACK;
    }
    
    private Node getBrother(Node node){
        if(null == node){
            return null;
        }
        Node parent = node.parentNode;
        if(null == parent){
            return null;
        }
        if(node.key.compareTo(parent.key) > 0){
            return parent.leftNode;
        }else{
            return parent.rightNode;
        }
    }
    
    public boolean delete(K key){
        if(null != key){
            if(null != root){
                return deleteNode(key, root, null);
            }
        }
        return false;
    }
    
    private boolean deleteNode(K key, Node current, Node parent){
        if(null != current){
            if(key.compareTo(current.key) > 0){
                return deleteNode(key, current.rightNode, current);
            }
            if(key.compareTo(current.key) < 0){
                return deleteNode(key, current.leftNode, current);
            }
            if(key.compareTo(current.key) == 0){
                if((null != current.leftNode) && (null != current.rightNode)){ //将要删除的节点下有两个子节点
                    dleTwoChildrenNode(current);
                    return true;
                }else{
                    if((null == current.leftNode) && (null == current.rightNode)){ //将要删除的节点没有子节点
                        deleteLeafFix(current);
                        if(current.key.compareTo(parent.key) > 0){
                            parent.rightNode = null;
                        }else{
                            parent.leftNode = null;
                        }
                        return true;
                    }else{ // 将要删除的节点下有一个子节点, 
                        dleOneChildNode(current);
                        return true;
                    }
                }
            }
        }
        return false;
    }
    
    private void dleOneChildNode(Node delNode){
        Node replaceNode = (null == delNode.leftNode) ? delNode.rightNode : delNode.leftNode;
        deltetLeafNode(delNode, replaceNode);
    }
    
    /**
     * 处理被删除节点有两个子节点的情况
     * @param target 将要被删除的节点
     */
    private void dleTwoChildrenNode(Node target){
        Node replaceNode = successor(target);
        if((null == replaceNode.rightNode) && (null == replaceNode.leftNode)){
            deltetLeafNode(target, replaceNode);
        }else{
            target.key = replaceNode.key;
            target.value = replaceNode.value;
            dleOneChildNode(replaceNode);
        }
    }
    
    private void deltetLeafNode(Node target, Node replaceNode){
        target.key = replaceNode.key;
        target.value = replaceNode.value;
        deleteLeafFix(replaceNode);
        if(replaceNode == replaceNode.parentNode.rightNode){
            replaceNode.parentNode.rightNode = null;
        }else{
            replaceNode.parentNode.leftNode = null;
        }
    }
    
    //找后继结点。即，查找"红黑树中数据值大于该结点"的"最小结点"
    private Node successor(Node node) {
        if (node == null){
            return null;
        }
        if (null != node.rightNode) { // 获取 后继节点
            Node p = node.rightNode;
            while (null != p.leftNode){
                 p = p.leftNode;
            }
            return p;
        } else {
            Node p = node.parentNode;
            Node ch = node;
            while (p != null && ch == p.rightNode) {
                ch = p;
                p = p.parentNode;
            }
            return p;
        }
    }